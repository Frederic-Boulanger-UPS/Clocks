<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Clocks (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Clocks</h1>

<span class="command">theory</span> <span class="name">Clocks</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Clocks</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Frédéric Boulanger frederic.boulanger@lri.fr, 2020 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Basic definitions&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
Time is represented as the natural numbers.
A clock represents an event that may occur or not at any time.
We model a clock as a function from nat to bool, which is True at every
instant when the clock ticks (the event occurs). 
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>clock</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; bool&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Periodic clocks&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
A clock is (k,p)-periodic if it ticks at instants separated by p instants,
starting at instant k.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>kp_periodic</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, nat, clock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_periodic k p c &#8801;
    (p &gt; 0) &#8743; (&#8704;n. c n = ((n &#8805; k) &#8743; ((n - k) mod p = 0)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A 1-periodic clock always ticks starting at its offset&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_periodic_ticks</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_periodic k 1 c&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8805; k&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>kp_periodic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A p-periodic clock is a (k,p)-periodic clock starting from a given offset.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_periodic p c &#8801; (&#8707;k. kp_periodic k p c)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p_periodic_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_periodic k p c &#10233; p_periodic p c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_periodic_def</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;No clock is 0-periodic.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_0_periodic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;p_periodic 0 c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>kp_periodic_def</span><span> </span><span>p_periodic_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A periodic clock is a p-periodic clock for a given period.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;periodic c &#8801; (&#8707;p. p_periodic p c)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>periodic_intro1</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_periodic p c &#10233; periodic c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_periodic_def</span><span> </span><span>periodic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>periodic_intro2</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_periodic k p c &#10233; periodic c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_periodic_intro</span><span> </span><span>periodic_intro1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Sporadic clocks&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
A clock is p-sporadic if it ticks at instants separated at least by p instants.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>p_sporadic</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, clock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic p c &#8801; (&#8704;t. c t &#10230; (&#8704;t&#39;. (t &lt; t&#39; &#8743; t&#39; &#8804; t+p) &#10230; &#172;(c t&#39;)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Any clock is 0-sporadic&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sporadic_0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic 0 c&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_sporadic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We define sporadic clock as p-sporadic clocks for some non null interval p.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sporadic c &#8801; (&#8707;p &gt; 0. p_sporadic p c)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sporadic_intro</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;p_sporadic p c;p &gt; 0&#10215; &#10233; sporadic c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sporadic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Properties of clocks&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Some useful lemmas about modulo.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_sporadic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((n::nat) mod p = 0)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;n&#39;. (n &lt; n&#39; &#8743; n&#39; &lt; n+p) &#10230; &#172;(n&#39; mod p = 0)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>less_imp_add_positive</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_offset_sporadic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(n::nat) &#8805; k&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(n - k) mod p = 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;n&#39;. (n &lt; n&#39; &#8743; n&#39; &lt; n+p) &#10230; &#172;((n&#39;-k) mod p = 0)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;n&#39;. n&#39; &gt; n &#10230; (n&#39;-k) &gt; (n-k)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>diff_less_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mod_sporadic</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A (p+1)-periodic clock is p-sporadic.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>periodic_suc_sporadic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_periodic (Suc p) c&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic p c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>p_periodic_def</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_periodic k (Suc p) c&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>kp_periodic_def</span><span> </span><span>p_sporadic_def</span><span> </span><span>mod_offset_sporadic</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Merging clocks&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The result of merging two clocks ticks whenever any of the two clocks ticks.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>merge</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[clock, clock] &#8658; clock&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8853;&#8250;</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c1 &#8853; c2 &#8801; &#955;t. c1 t &#8744; c2 t&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Merging two sporadic clocks does not necessary yields a sporadic clock.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_no_sporadic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;c c&#39;. sporadic c &#8743; sporadic c&#39; &#8743; &#172;sporadic (c&#8853;c&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span>clock</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c = (&#955;t. t mod 2 = 0)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>c&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span>clock</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c&#39; = (&#955;t. t &#8805; 1 &#8743; (t-1) mod 2 = 0)&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_periodic 2 c&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_periodic_def</span><span> </span><span>kp_periodic_def</span><span>
</span><span>                        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sporadic c&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>periodic_suc_sporadic</span><span> </span><span>Suc_1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>sporadic_def</span><span> </span><span>zero_less_one</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_periodic 2 c&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_periodic_def</span><span> </span><span>kp_periodic_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sporadic c&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>periodic_suc_sporadic</span><span> </span><span>Suc_1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>sporadic_def</span><span> </span><span>zero_less_one</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;sporadic (c&#8853;c&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sporadic (c &#8853; c&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p &gt; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic p (c &#8853; c&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sporadic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t. (c&#8853;c&#39;) t &#10230; (&#8704;t&#39;. (t &lt; t&#39; &#8743; t&#39; &#8804; t+p) &#10230; &#172;((c&#8853;c&#39;) t&#39;))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>p_sporadic_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(c&#8853;c&#39;) 0&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_def</span><span> </span><span>c&#39;_def</span><span> </span><span>merge_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(c&#8853;c&#39;) 1&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_def</span><span> </span><span>c&#39;_def</span><span> </span><span>merge_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;*&quot;</span></span></span><span> </span><span>Suc_leI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Get the number of ticks on a clock from the beginning up to instant n.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ticks_up_to</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[clock, nat] &#8658; nat&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to c n = card {t. t &#8804; n &#8743; c t}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;There cannot be more than n event occurrences during n instants.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to c n &#8804; Suc n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite {t::nat. t &#8804; n}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t::nat. t &#8804; n &#8743; c t} &#8838; {t::nat. t &#8804; n}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t::nat. t &#8804; n} = Suc n&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite</span><span> </span><span>incl</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ticks_up_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Counting event occurrences.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count b n &#8801; if b then Suc n else n&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The count of event occurrences cannot grow by more than one at each instant.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_inc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count b n &#8804; Suc n&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Alternative definition of the number of event occurrences using fold.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ticks_up_to_fold</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[clock, nat] &#8658; nat&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to_fold c n = fold count (map c [0..&lt;Suc n]) 0&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Alternative definition of the number of event occurrences as a function.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>ticks_up_to_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[clock, nat] &#8658; nat&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to_fun c 0 = count (c 0) 0&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to_fun c (Suc n) = count (c (Suc n)) (ticks_up_to_fun c n)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
Proof that the original definition and the function definition are equivalent.
Use this to generate code.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ticks_up_to_is_fun</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to c n = ticks_up_to_fun c n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to c 0 = card {t. t &#8804; 0 &#8743; c t}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>ticks_up_to_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = card {t. t=0 &#8743; c t}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = (if c 0 then 1 else 0)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Collect_conv_if</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = ticks_up_to_fun c 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ticks_up_to_fun.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>count_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c (Suc n)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. t &#8804; Suc n &#8743; c t} = insert (Suc n) {t. t &#8804; n &#8743; c t}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to c (Suc n) = Suc (ticks_up_to c n)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ticks_up_to_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = Suc (ticks_up_to_fun c n)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>count_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c (Suc n)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. t &#8804; Suc n &#8743; c t} = {t. t &#8804; n &#8743; c t}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ticks_up_to c (Suc n) = ticks_up_to c n&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ticks_up_to_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = ticks_up_to_fun c n&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>count_def</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;c (Suc n)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Number of event occurrences during an n instant window starting at @{term&#8249;t<span class="hidden">&#8681;</span><sub>0</sub>&#8250;}.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tick_count</span><span> </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[clock, nat, nat] &#8658; nat&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count c t<span class="hidden">&#8681;</span><sub>0</sub> n &#8801; card {t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The number of event occurrences is monotonous with regard to the window width.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tick_count_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n&#39; &#8805; n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count c t<span class="hidden">&#8681;</span><sub>0</sub> n&#39; &#8805; tick_count c t<span class="hidden">&#8681;</span><sub>0</sub> n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n&#39; &#8743; c t}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t} &#8838; {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n&#39; &#8743; c t}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t}
        &#8804; card {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n&#39; &#8743; c t}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite</span><span> </span><span>incl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tick_count_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The interval [t, t+n[ contains n instants.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_interval</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n} = n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+(Suc n)} = insert (t<span class="hidden">&#8681;</span><sub>0</sub>+n) {t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+(Suc n)} = Suc (card {t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n})&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc.IH</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;There cannot be more than n occurrences of an event in an interval of n instants.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tick_count_bound</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count c t<span class="hidden">&#8681;</span><sub>0</sub> n &#8804; n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite {t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t} &#8838; {t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tick_count_def</span><span> </span><span>card_interval</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite</span><span> </span><span>incl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;No event occurrence occur in 0 instant.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tick_count_0</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count c t<span class="hidden">&#8681;</span><sub>0</sub> 0 = 0&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tick_count_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Event occurrences starting from instant 0 are event occurrences from the beginning.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tick_count_orig</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count c 0 (Suc n) = ticks_up_to c n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tick_count_def</span><span> </span><span>ticks_up_to_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_Suc_eq_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
Counting event occurrences between two instants is simply subtracting
occurrence counts from the beginning.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tick_count_diff</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count c (Suc t<span class="hidden">&#8681;</span><sub>0</sub>) n = (ticks_up_to c (t<span class="hidden">&#8681;</span><sub>0</sub>+n)) - (ticks_up_to c t<span class="hidden">&#8681;</span><sub>0</sub>)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. t &#8804; t<span class="hidden">&#8681;</span><sub>0</sub> &#8743; c t} &#8838; {t. t &#8804; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. (Suc t<span class="hidden">&#8681;</span><sub>0</sub>) &#8804; t &#8743; t &lt; (Suc t<span class="hidden">&#8681;</span><sub>0</sub>)+n &#8743; c t}
      = {t. t &#8804; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t} - {t. t &#8804; t<span class="hidden">&#8681;</span><sub>0</sub> &#8743; c t}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t. (Suc t<span class="hidden">&#8681;</span><sub>0</sub>) &#8804; t &#8743; t &lt; (Suc t<span class="hidden">&#8681;</span><sub>0</sub>)+n &#8743; c t}
       = card {t. t &#8804; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t} - card {t. t &#8804; t<span class="hidden">&#8681;</span><sub>0</sub> &#8743; c t}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_Diff_subset</span><span> </span><span>incl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tick_count_def</span><span> </span><span>ticks_up_to_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The merge of two clocks has less ticks than the union of the ticks of the two clocks.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tick_count_merge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count (c&#8853;c&#39;) t<span class="hidden">&#8681;</span><sub>0</sub> n  &#8804; tick_count c t<span class="hidden">&#8681;</span><sub>0</sub> n + tick_count c&#39; t<span class="hidden">&#8681;</span><sub>0</sub> n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; ((c&#8853;c&#39;) t)}
        = {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t} &#8746; {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c&#39; t}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>merge_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; ((c&#8853;c&#39;) t)}
          &#8804; card {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c t}
            + card {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+n &#8743; c&#39; t}&#8250;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_Un_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tick_count_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Bounded clocks&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;An (n,m)-bounded clock does not tick more than m times in a n interval of width n.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bounded</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, nat, clock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded n m c &#8801; &#8704;t. tick_count c t n &#8804; m&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;All clocks are (n,n)-bounded.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded n n c&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tick_count_bound</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_imp_less_Suc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A sporadic clock is bounded.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spor_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t::nat. c t &#10230; (&#8704;t&#39;. (t &lt; t&#39; &#8743; t&#39; &#8804; t+n) &#10230; &#172;(c t&#39;))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t::nat. card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;} &#8804; 1&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;} &#8804; 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c t&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t&#39;. (t &lt; t&#39; &#8743; t&#39; &#8804; t+n) &#10230; &#172;(c t&#39;)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>empty</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &lt; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;} = 0&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite {t&#39;. t &lt; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>notin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t &#8713; {t&#39;. t &lt; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;}
            = insert t {t&#39;. t &lt; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c t&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;} = 1&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty</span><span> </span><span>card_insert_disjoint</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite</span><span> </span><span>notin</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;tt. t &lt; tt &#8743; tt &#8804; t+n &#8743; c tt&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Among the instants at which c ticks, there is an earliest one.*)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;ttmin. t &lt; ttmin &#8743; ttmin &#8804; t+n &#8743; c ttmin
              &#8743; (&#8704;tt&#39;. (t &lt; tt&#39; &#8743; tt&#39; &#8804; t+n &#8743; c tt&#39;) &#10230; ttmin &#8804; tt&#39;)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_lessD1</span><span> </span><span>add_less_mono1</span><span> </span><span>assms</span><span> </span><span>le_eq_less_or_eq</span><span>
</span><span>              </span><span>le_refl</span><span> </span><span>less_imp_le_nat</span><span> </span><span>nat_le_iff_add</span><span> </span><span>nat_le_linear</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ttmin</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>tmin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t &lt; ttmin &#8743; ttmin &#8804; t+n &#8743; c ttmin
                &#8743; (&#8704;tt&#39;. (t &lt; tt&#39; &#8743; tt&#39; &#8804; t+n &#8743; c tt&#39;) &#10230; ttmin &#8804; tt&#39;)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tick</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c ttmin&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>notick</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8704;t&#39;. ttmin &lt; t&#39; &#8743; t&#39; &#8804; ttmin + n &#10230; &#172; c t&#39;)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t&#39;. (t &lt; t&#39; &#8743; t&#39; &lt; ttmin) &#10230; &#172;c t&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tmin</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;c t&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>notick</span><span> </span><span>tmin</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t&#39;. (ttmin &lt; t&#39; &#8743; t&#39; &#8804; t+n) &#10230; &#172;c t&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t&#39;::nat. (t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;) &#10230; t&#39; = ttmin&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tick</span><span> </span><span>tmin</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;c t&#8250;</span></span></span><span> </span><span>le_eq_less_or_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;} = {ttmin}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tmin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;} = 1&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;c t&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#10230; &#172;c t&#39;&#8250;</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_less_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;} = 0&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;An n-sporadic clock is (n+1, 1)-bounded.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spor_bounded</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic n c&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded (Suc n) 1 c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t. c t &#10230; (&#8704;t&#39;. (t &lt; t&#39; &#8743; t&#39; &#8804; t+n) &#10230; &#172;(c t&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_sporadic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>spor_bound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t. card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &#8804; t+n &#8743; c t&#39;} &#8804; 1&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t. card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; Suc (t+n) &#8743; c t&#39;} &#8804; 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_Suc_eq_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t. card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; t + Suc n &#8743; c t&#39;} &#8804; 1&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_def</span><span> </span><span>tick_count_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;An n-sporadic clock is (n+2, 2)-bounded.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spor_bounded2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic n c&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded (Suc (Suc n)) 2 c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>spor_bounded</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>*</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t. card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; t + Suc n &#8743; c t&#39;} &#8804; 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_def</span><span> </span><span>tick_count_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t. card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; Suc (t + Suc n) &#8743; c t&#39;} &#8804; Suc 1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>*</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>**</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; t + Suc n &#8743; c t&#39;} &#8804; 1&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; Suc (t + Suc n) &#8743; c t&#39;} &#8804; Suc 1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c (t + Suc n)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; Suc (t + Suc n) &#8743; c t&#39;}
                = insert (t+Suc n) {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; t + Suc n &#8743; c t&#39;}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; Suc (t + Suc n) &#8743; c t&#39;}
                = Suc (card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; t + Suc n &#8743; c t&#39;})&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>**</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; Suc (t + Suc n) &#8743; c t&#39;}
                = {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; t + Suc n &#8743; c t&#39;}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; Suc (t + Suc n) &#8743; c t&#39;}
                  = (card {t&#39;. t &#8804; t&#39; &#8743; t&#39; &lt; t + Suc n &#8743; c t&#39;})&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>**</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_def</span><span> </span><span>tick_count_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_1</span><span> </span><span>add_Suc_right</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A bounded clock on an interval is also bounded on a narrower interval.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded n&#39; m c&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n&#39; &#8805; n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded n m c&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tick_count_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>order_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The merge of two bounded clocks is bounded.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bounded_merge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded n m c&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded n&#39; m&#39; c&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n&#39; &#8805; n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded n (m+m&#39;) (c&#8853;c&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tick_count_merge</span><span> </span><span>bounded_less</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>add_mono</span><span> </span><span>order_trans</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The merge of two sporadic clocks is bounded.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sporadic_bounded1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic n c&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic n&#39; c&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n&#39; &#8805; n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded (Suc n) 2 (c&#8853;c&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded (Suc n) 1 c&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spor_bounded</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded (Suc n&#39;) 1 c&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spor_bounded</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc n&#39; &#8805; Suc n&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1+1 = (2::nat)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>bounded_merge</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Main theorem&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The merge of two sporadic clocks is bounded on the min of the bounding intervals.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>sporadic_bounded_min</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic n c&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_sporadic n&#39; c&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded (Suc (min n n&#39;)) 2 (c&#8853;c&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>bounded_less</span><span> </span><span>bounded_merge</span><span> </span><span>sporadic_bounded1</span><span> </span><span>spor_bounded</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>min.cobounded1</span><span> </span><span>min_Suc_Suc</span><span> </span><span>min_def</span><span> </span><span>one_add_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Tests&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c1::clock &#8801; (&#955;t. t &#8805; 1 &#8743; (t-1) mod 2 = 0)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c2::clock &#8801; (&#955;t. t &#8805; 2 &#8743; (t-2) mod 3 = 0)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c1 0&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c1 1&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c1 2&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c1 3&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c2 0&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c2 1&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c2 2&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c2 3&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c2 4&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c2 5&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_periodic 1 2 c1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kp_periodic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_periodic 2 3 c2&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kp_periodic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c3 &#8801; c1 &#8853; c2&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;map c1 [0,1,2,3,4,5,6,7,8,9,10]&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;map c2 [0,1,2,3,4,5,6,7,8,9,10]&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;map c3 [0,1,2,3,4,5,6,7,8,9,10]&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>interv_2</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub> + 2 &#8743; 1 &#8804; t &#8743; (t - 1) mod 2 = 0} = {t. (t = t<span class="hidden">&#8681;</span><sub>0</sub> &#8744; t = t<span class="hidden">&#8681;</span><sub>0</sub> + 1) &#8743; 1 &#8804; t &#8743; (t - 1) mod 2 = 0}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bounded 2 1 c1&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;t. tick_count c1 t 2 &#8804; 1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t<span class="hidden">&#8681;</span><sub>0</sub></span><span class="delimiter">::</span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count c1 t<span class="hidden">&#8681;</span><sub>0</sub> 2 &#8804; 1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t<span class="hidden">&#8681;</span><sub>0</sub></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tick_count c1 t<span class="hidden">&#8681;</span><sub>0</sub> 2 = ticks_up_to c1 1&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tick_count_orig</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>numeral_2_eq_2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = card {t::nat. t &#8804; 1 &#8743; 1 &#8804; t &#8743; (t-1) mod 2 = 0}&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ticks_up_to_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... &#8804;  card {t::nat. t &#8804; 1 &#8743; 1 &#8804; t}&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Collect_cong</span><span>
</span><span>                </span><span>cancel_comm_monoid_add_class.diff_cancel</span><span> </span><span>le_antisym</span><span> </span><span>le_refl</span><span> </span><span>mod_0</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = card {t::nat. t = 1}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_antisym</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = 1&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(t<span class="hidden">&#8681;</span><sub>0</sub>-1) mod 2 = 0&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t<span class="hidden">&#8681;</span><sub>0</sub> mod 2 &#8800; 0&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. (t = t<span class="hidden">&#8681;</span><sub>0</sub> &#8744; t = t<span class="hidden">&#8681;</span><sub>0</sub> + 1) &#8743; 1 &#8804; t &#8743; (t - 1) mod 2 = 0} = {t<span class="hidden">&#8681;</span><sub>0</sub>}&#8250;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub> + 2 &#8743; 1 &#8804; t &#8743; (t - 1) mod 2 = 0} = {t<span class="hidden">&#8681;</span><sub>0</sub>}&#8250;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interv_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tick_count_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t<span class="hidden">&#8681;</span><sub>0</sub> mod 2 = 0&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. (t = t<span class="hidden">&#8681;</span><sub>0</sub> &#8744; t = t<span class="hidden">&#8681;</span><sub>0</sub> + 1) &#8743; 1 &#8804; t &#8743; (t - 1) mod 2 = 0} = {t<span class="hidden">&#8681;</span><sub>0</sub>+1}&#8250;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub> + 2 &#8743; 1 &#8804; t &#8743; (t - 1) mod 2 = 0} = {t<span class="hidden">&#8681;</span><sub>0</sub>+1}&#8250;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>interv_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tick_count_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
