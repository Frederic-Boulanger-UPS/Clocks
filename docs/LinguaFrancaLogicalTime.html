<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory LinguaFrancaLogicalTime (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory LinguaFrancaLogicalTime</h1>

<span class="command">theory</span> <span class="name">LinguaFrancaLogicalTime</span><br/>
<span class="keyword">imports</span> <a href="LinguaFrancaClocks.html"><span class="name">LinguaFrancaClocks</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>LinguaFrancaLogicalTime</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>LinguaFrancaClocks</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Logical time&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
Logical time is a natural number that is attached to instants.
Logical time can stay constant for an arbitrary number of instants, but it cannot decrease.
When logical time stays constant for an infinite number of instants, we have a Zeno condition.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>time</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t::nat&#8658;nat. mono t}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_time</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
A chronometric clock is a clock associated with a time line.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>chronoclock</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#215;time&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
@term{&#8249;c &#8711; t&#8250;} tells whether chronometric clock @{term c} ticks at instant @{term t}.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ticks</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[chronoclock, nat] &#8658; bool&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8711;&#8250;</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;c &#8711; t &#8801; (fst c) t&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
@term{&#8249;c<span class="hidden">&#8664;</span><sub>t<span class="hidden">&#8665;</span></sub>&#8250;} is the logical time on clock @{term c} at instant @{term t}.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>time_at</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[chronoclock, nat] &#8658; nat&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_<span class="hidden">&#8664;</span><sub>_<span class="hidden">&#8665;</span></sub>&#8250;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span> </span><span>60</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;c t. (snd c) t&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>chronoclocks_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ticks_def</span><span> </span><span>time_at_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
As consequence of the definition of the @{type &#8249;time&#8250;} type, @{term &#8249;(&#8711;)&#8250;} is monotonous for any clock.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_chronotime</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mono (time_at c)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rep_time</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
An event occurs at a given time if the clock ticks at some instant at that time.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>occurs</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;occurs n c &#8801; &#8707;k. (c &#8711; k &#8743; c<span class="hidden">&#8664;</span><sub>k<span class="hidden">&#8665;</span></sub> = n)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
An event occurs once at a given time if the clock ticks at exactly one instant at that time.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>occurs_once</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;occurs_once n c &#8801; &#8707;!k. (c &#8711; k &#8743; c<span class="hidden">&#8664;</span><sub>k<span class="hidden">&#8665;</span></sub> = n)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>occurs_once_occurs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;occurs_once n c &#10233; occurs n c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>occurs_once_def</span><span> </span><span>occurs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
A clock is strict at a given time if it ticks at most once at that time.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strict_at</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;strict_at n c &#8801; (occurs n c &#10230; occurs_once n c)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strict_clock</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chronoclock &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;strict_clock c &#8801; (&#8704;n. strict_at n c)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Chrono-periodic and chrono-sporadic clocks&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
The introduction of logical time allows us to define periodicity and sporadicity
on logical time instead of instant index.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>kp_chronoperiodic</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, nat, chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_chronoperiodic k p c &#8801; (p &gt; 0) &#8743; (&#8704;n. occurs n c = ((n &#8805; k) &#8743; ((n - k) mod p = 0)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>p_chronoperiodic</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_chronoperiodic p c &#8801; &#8707;k. kp_chronoperiodic k p c&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>chronoperiodic</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chronoperiodic c &#8801; &#8707;p. p_chronoperiodic p c&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
A clock is strictly chronoperiodic if it ticks only once at the logical times when it ticks.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>chronoperiodic_strict</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chronoperiodic_strict c &#8801; chronoperiodic c &#8743; strict_clock c&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>p_chronoperiodic_strict</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_chronoperiodic_strict p c &#8801; p_chronoperiodic p c &#8743; strict_clock c&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chronoperiodic_strict c &#10233; chronoperiodic c&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chronoperiodic_strict_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>p_chronosporadic</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[nat, chronoclock] &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_chronosporadic p c &#8801;
    &#8704;t. occurs t c &#10230; (&#8704;t&#39;. (t&#39; &gt; t &#8743; occurs t&#39; c) &#10230; t&#39; &gt; t + p)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_chronosporadic_strict p c &#8801; p_chronosporadic p c &#8743; strict_clock c&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chronosporadic c &#8801; (&#8707;p &gt; 0. p_chronosporadic p c)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chronosporadic_strict c &#8801; chronosporadic c &#8743; strict_clock c&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chrono_periodic_suc_sporadic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_chronoperiodic (p+1) c&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_chronosporadic p c&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>p_chronoperiodic_def</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;kp_chronoperiodic k (p+1) c&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>*</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;n. occurs n c = ((n &#8805; k) &#8743; ((n - k) mod (p+1) = 0))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kp_chronoperiodic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mod_offset_sporadic&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p+1&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;n. occurs n c &#10230; (&#8704;n&#39;. (n &lt; n&#39; &#8743; ((n&#39;-k) mod (p+1) = 0)) &#10230; n&#39; &#8805; n+p+1)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_chronosporadic_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;*&quot;</span></span></span><span> </span><span>Suc_le_lessD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chrono_periodic_suc_sporadic_strict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_chronoperiodic_strict (p+1) c&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;p_chronosporadic_strict p c&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>chrono_periodic_suc_sporadic</span><span>
</span><span>        </span><span>p_chronoperiodic_strict_def</span><span> </span><span>p_chronosporadic_strict_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
Number of ticks up to a given logical time.
This counts distinct ticks that happen at the same logical time.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>chrono_dense_up_to</span><span> </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[chronoclock, nat] &#8658; nat&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chrono_dense_up_to c n = card {t. c<span class="hidden">&#8664;</span><sub>t<span class="hidden">&#8665;</span></sub> &#8804; n &#8743; c &#8711; t}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
A clock is Zeno if it ticks an infinite number of times in a finite amount of time.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>zeno_clock</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chronoclock &#8658; bool&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;zeno_clock c &#8801; (&#8707;&#969;. infinite {t. c<span class="hidden">&#8664;</span><sub>t<span class="hidden">&#8665;</span></sub> &#8804; &#969; &#8743; c &#8711; t})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
Number of occurrences of an event up to a given logical time.
This does not count separately ticks that occur at the same logical time.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>chrono_up_to</span><span> </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[chronoclock, nat] &#8658; nat&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chrono_up_to c n = card {t. t &#8804; n &#8743; occurs t c}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
For any time n, a non Zeno clock has less occurrences than ticks up to n.
This is also true for Zeno clock, but we count ticks and occurrences using @{term &#8249;card&#8250;},
and in Isabelle/HOL, the cardinal of an infinite set is 0, so the inequality breaks when
there are infinitely many ticks before a given time.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_zeno_sparse</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;zeno_clock c&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;chrono_up_to c n &#8804; chrono_dense_up_to c n&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite {t. c<span class="hidden">&#8664;</span><sub>t<span class="hidden">&#8665;</span></sub> &#8804; n &#8743; c &#8711; t}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>zeno_clock_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>occurs_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;f. &#8704;t. t &#8804; n &#8743; occurs t c &#10230;
        (&#8707;k. f k = t &#8743; c<span class="hidden">&#8664;</span><sub>k<span class="hidden">&#8665;</span></sub> &#8804; n &#8743; c &#8711; k)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;f. &#8704;t &#8712; {t. t &#8804; n &#8743; occurs t c}.
          &#8707;k. f k = t &#8743; k &#8712; {k. c<span class="hidden">&#8664;</span><sub>k<span class="hidden">&#8665;</span></sub> &#8804; n &#8743; c &#8711; k}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;f. {t. t &#8804; n &#8743; occurs t c} &#8838; image f {k. c<span class="hidden">&#8664;</span><sub>k<span class="hidden">&#8665;</span></sub> &#8804; n &#8743; c &#8711; k}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t. t &#8804; n &#8743; occurs t c} &#8804; card {k. c<span class="hidden">&#8664;</span><sub>k<span class="hidden">&#8665;</span></sub> &#8804; n &#8743; c &#8711; k}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>surj_card_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chrono_up_to_def</span><span> </span><span>chrono_dense_up_to_def</span><span> </span><span>occurs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Number of event occurrences during a time window.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>occurrence_count</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[chronoclock, nat, nat] &#8658; nat&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;occurrence_count c t<span class="hidden">&#8681;</span><sub>0</sub> d &#8801; card {t. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub> + d &#8743; occurs t c}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The number of event occurrences is monotonous with regard to the window width.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>occ_count_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;d&#39; &#8805; d&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;occurrence_count c t<span class="hidden">&#8681;</span><sub>0</sub> d&#39; &#8805; occurrence_count c t<span class="hidden">&#8681;</span><sub>0</sub> d&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>finite</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+d&#39; &#8743; occurs t c}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+d &#8743; occurs t c} &#8838; {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+d&#39; &#8743; occurs t c}&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+d &#8743; occurs t c}
        &#8804; card {t::nat. t<span class="hidden">&#8681;</span><sub>0</sub> &#8804; t &#8743; t &lt; t<span class="hidden">&#8681;</span><sub>0</sub>+d&#39; &#8743; occurs t c}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>finite</span><span> </span><span>incl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>occurrence_count_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
